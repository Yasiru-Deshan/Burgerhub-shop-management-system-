{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar React = require('react');\n\nvar url = _interopDefault(require('url'));\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n/**\r\n * Removes any properties that undefined\r\n * @param obj - any object\r\n */\n\n\nfunction removeUndefined(obj) {\n  return Object.entries(obj).reduce(function (acc, _ref) {\n    var key = _ref[0],\n        value = _ref[1];\n\n    if (value !== undefined) {\n      acc[key] = value;\n    }\n\n    return acc;\n  }, {});\n}\n/**\r\n * An id that can be appended to a URL in order to identify a particular image within a browser cache\r\n *\r\n * Many random-image-generating services will return different images for the same URL,\r\n * but the browser will cache the result for the first request and will serve the cached response for subsequent requests\r\n * which means that all requests will effectively return the _same_ image every time.\r\n * So, we circumvent the browser's caching by appending a unique id to each request which ensures a cache-miss\r\n */\n\n\nfunction generateCacheId() {\n  return (Math.random() * 100000).toFixed(0);\n}\n/**\r\n * Checks whether the input string is valid hex and then removes the hash\r\n * @param {string} hex\r\n */\n\n\nfunction sanitizeHex(hex) {\n  if (!/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex)) {\n    throw new Error(\"Expected valid hex color, got \\\"\" + hex + \"\\\"\");\n  }\n\n  return hex.substring(1); // remove the hash\n}\n/**\r\n * Generates a URL for a custom placeholder image\r\n *\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {object} [options]\r\n * @param {string} [options.backgroundColor={a light gray}]\r\n * @param {string} [options.text={the size of the image e.g. \"200x100\"}]\r\n * @param {string} [options.textColor={auto-contrast with backgroundColor}]\r\n */\n\n\nfunction generateCustomPlaceholderURL(width, height, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      backgroundColor = _options.backgroundColor,\n      textColor = _options.textColor,\n      text = _options.text;\n  return url.format({\n    protocol: 'https',\n    host: 'via.placeholder.com',\n    pathname: [width + \"x\" + height, backgroundColor ? sanitizeHex(backgroundColor) : '', textColor ? sanitizeHex(textColor) : undefined].filter(function (part) {\n      return part !== undefined;\n    }).join('/'),\n    query: removeUndefined({\n      text: text\n    })\n  });\n}\n\nvar CustomPlaceholder = function CustomPlaceholder(props) {\n  var width = props.width,\n      height = props.height,\n      backgroundColor = props.backgroundColor,\n      textColor = props.textColor,\n      text = props.text,\n      src = props.src,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"width\", \"height\", \"backgroundColor\", \"textColor\", \"text\", \"src\"]);\n\n  if (src !== undefined) {\n    console.warn('Do not define the `src` prop for <CustomPlaceholder />; the src will be generated');\n  }\n\n  return React.createElement('img', _extends({\n    src: generateCustomPlaceholderURL(width, height, {\n      backgroundColor: backgroundColor,\n      textColor: textColor,\n      text: text\n    }),\n    alt: 'placeholder'\n  }, htmlProps));\n};\n/**\r\n * Generates a URL for a random placeholder photo\r\n *\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {object} [options]\r\n * @param {string} [options.grayscale={boolean}]\r\n */\n\n\nfunction generatePhotoPlaceholderURL(width, height, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$grayscale = _options.grayscale,\n      grayscale = _options$grayscale === void 0 ? false : _options$grayscale;\n  return url.format({\n    protocol: 'https',\n    host: 'picsum.photos',\n    pathname: \"/\" + width + \"/\" + height,\n    query: removeUndefined({\n      // if grayscale query param is present, the image will be grayscale, even if it is grayscale=false or grayscale=<nothing>\n      // so we completely omit the key if grayscale is not true\n      grayscale: grayscale ? grayscale : undefined,\n      // automatically cache-bust the url so that same-size images on the page don't get the same image\n      cacheId: generateCacheId()\n    })\n  });\n}\n\nvar PhotoPlaceholder = function PhotoPlaceholder(props) {\n  var width = props.width,\n      height = props.height,\n      grayscale = props.grayscale,\n      src = props.src,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"width\", \"height\", \"grayscale\", \"src\"]);\n\n  if (src !== undefined) {\n    console.warn('Do not define the `src` prop for <PhotoPlaceholder />; the src will be generated');\n  }\n\n  var _React$useState = React.useState(undefined),\n      url = _React$useState[0],\n      setURL = _React$useState[1]; // generating the URL is side-effectful because it generates a new random cache-busting query param\n  // we use layout effect so that the url is calculated before the element is flushed to the DOM\n\n\n  React.useLayoutEffect(function () {\n    setURL(generatePhotoPlaceholderURL(width, height, {\n      grayscale: grayscale\n    }));\n  }, [width, height, grayscale]);\n  return React.createElement('img', _extends({\n    src: url,\n    alt: 'Placeholder'\n  }, htmlProps));\n};\n\nexports.CustomPlaceholder = CustomPlaceholder;\nexports.PhotoPlaceholder = PhotoPlaceholder;\nexports.generateCustomPlaceholderURL = generateCustomPlaceholderURL;\nexports.generatePhotoPlaceholderURL = generatePhotoPlaceholderURL;","map":{"version":3,"sources":["../src/util.ts","../src/components/CustomPlaceholder.tsx","../src/components/PhotoPlaceholder.ts"],"names":["removeUndefined","obj","key","value","acc","generateCacheId","Math","hex","generateCustomPlaceholderURL","width","height","options","backgroundColor","textColor","text","protocol","host","pathname","sanitizeHex","part","query","CustomPlaceholder","src","htmlProps","props","console","alt","generatePhotoPlaceholderURL","grayscale","cacheId","PhotoPlaceholder","url","setURL","React"],"mappings":"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","sourcesContent":["/**\n * Removes any properties that undefined\n * @param obj - any object\n */\nexport function removeUndefined(obj: { [key: string]: any }) {\n  return Object.entries(obj).reduce<{ [key: string]: any }>(\n    (acc, [key, value]) => {\n      if (value !== undefined) {\n        acc[key] = value;\n      }\n\n      return acc;\n    },\n    {}\n  );\n}\n\n/**\n * An id that can be appended to a URL in order to identify a particular image within a browser cache\n *\n * Many random-image-generating services will return different images for the same URL,\n * but the browser will cache the result for the first request and will serve the cached response for subsequent requests\n * which means that all requests will effectively return the _same_ image every time.\n * So, we circumvent the browser's caching by appending a unique id to each request which ensures a cache-miss\n */\nexport function generateCacheId() {\n  return (Math.random() * 100000).toFixed(0);\n}\n","import * as React from 'react';\nimport url from 'url';\nimport { removeUndefined } from '../util';\n\n/**\n * Checks whether the input string is valid hex and then removes the hash\n * @param {string} hex\n */\nfunction sanitizeHex(hex: string) {\n  if (!/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex)) {\n    throw new Error(`Expected valid hex color, got \"${hex}\"`);\n  }\n\n  return hex.substring(1); // remove the hash\n}\n\n/**\n * Generates a URL for a custom placeholder image\n *\n * @param {number} width\n * @param {number} height\n * @param {object} [options]\n * @param {string} [options.backgroundColor={a light gray}]\n * @param {string} [options.text={the size of the image e.g. \"200x100\"}]\n * @param {string} [options.textColor={auto-contrast with backgroundColor}]\n */\nexport function generateCustomPlaceholderURL(\n  width: number,\n  height: number,\n  options: {\n    backgroundColor?: string;\n    textColor?: string;\n    text?: string;\n  } = {}\n) {\n  const { backgroundColor, textColor, text } = options;\n\n  return url.format({\n    protocol: 'https',\n    host: 'via.placeholder.com',\n    pathname: [\n      `${width}x${height}`,\n      backgroundColor ? sanitizeHex(backgroundColor) : '',\n      textColor ? sanitizeHex(textColor) : undefined,\n    ]\n      .filter(part => part !== undefined)\n      .join('/'),\n    query: removeUndefined({\n      text,\n    }),\n  });\n}\n\nexport const CustomPlaceholder = (\n  props: JSX.IntrinsicElements['img'] & {\n    width: number;\n    height: number;\n    backgroundColor?: string;\n    textColor?: string;\n    text?: string;\n  }\n): React.DetailedReactHTMLElement<\n  React.ImgHTMLAttributes<HTMLImageElement>,\n  HTMLImageElement\n> => {\n  const {\n    width,\n    height,\n    backgroundColor,\n    textColor,\n    text,\n    src,\n    ...htmlProps\n  } = props;\n\n  if (src !== undefined) {\n    console.warn(\n      'Do not define the `src` prop for <CustomPlaceholder />; the src will be generated'\n    );\n  }\n\n  return React.createElement('img', {\n    src: generateCustomPlaceholderURL(width, height, {\n      backgroundColor,\n      textColor,\n      text,\n    }),\n    alt: 'placeholder',\n    ...htmlProps,\n  });\n};\n","import * as React from 'react';\nimport url from 'url';\nimport { removeUndefined, generateCacheId } from '../util';\n\n/**\n * Generates a URL for a random placeholder photo\n *\n * @param {number} width\n * @param {number} height\n * @param {object} [options]\n * @param {string} [options.grayscale={boolean}]\n */\nexport function generatePhotoPlaceholderURL(\n  width: number,\n  height: number,\n  options: {\n    grayscale?: boolean;\n  } = {}\n) {\n  const { grayscale = false } = options;\n\n  return url.format({\n    protocol: 'https',\n    host: 'picsum.photos',\n    pathname: `/${width}/${height}`,\n    query: removeUndefined({\n      // if grayscale query param is present, the image will be grayscale, even if it is grayscale=false or grayscale=<nothing>\n      // so we completely omit the key if grayscale is not true\n      grayscale: grayscale ? grayscale : undefined,\n      // automatically cache-bust the url so that same-size images on the page don't get the same image\n      cacheId: generateCacheId(),\n    }),\n  });\n}\n\nexport const PhotoPlaceholder = (\n  props: JSX.IntrinsicElements['img'] & {\n    width: number;\n    height: number;\n    grayscale?: boolean;\n  }\n): React.DetailedReactHTMLElement<\n  React.ImgHTMLAttributes<HTMLImageElement>,\n  HTMLImageElement\n> => {\n  const { width, height, grayscale, src, ...htmlProps } = props;\n\n  if (src !== undefined) {\n    console.warn(\n      'Do not define the `src` prop for <PhotoPlaceholder />; the src will be generated'\n    );\n  }\n\n  const [url, setURL] = React.useState<string | undefined>(undefined);\n\n  // generating the URL is side-effectful because it generates a new random cache-busting query param\n  // we use layout effect so that the url is calculated before the element is flushed to the DOM\n  React.useLayoutEffect(() => {\n    setURL(\n      generatePhotoPlaceholderURL(width, height, {\n        grayscale,\n      })\n    );\n  }, [width, height, grayscale]);\n\n  return React.createElement('img', {\n    src: url,\n    alt: 'Placeholder',\n    ...htmlProps,\n  });\n};\n"]},"metadata":{},"sourceType":"script"}